# 结构型模式

1. Adapter
	- 意图
		将一个类的接口转换为客户希望的另一个接口。
	- 别名
		Wrapper
	- 适用性
		- 想使用一个已经存在的类，而它的接口不符合你的需求。
		- 想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类协同工作。
		- 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。
	- 效果
		- 用一个具体的Adapter类对Adaptee和Target进行匹配
		- 使得重定义Adaptee的行为比较困难
		- 需要考虑因素：
			- Adapter的匹配程度
			- 可插入的Adapter
			- 使用Dual Adapter提供透明操作
	- 实现
		- **可插入的适配器**
			- 使用抽象操作
			- 使用代理对象
			- 参数化的适配器
	- 相关模式
		- Bridge的结构与对象适配器类似，但是Bridge模式和出发点不同：Bridge目的是将接口部分和实现部分分离，从而对它们可以对它们可以较为容易也相对独立的加以改变。
		- Decorator模式增强了其他对象的功能而同时又不改变它的接口。因此decorator对应用程序的透明性比适配器好。
		- Proxy在不改变它的接口的条件下，为另一个对象定义了一个代理

2. Bridge
	- 意图
		将抽象部分与它的实现部分分离，使它们都可以独立地变化。
	- 别名
		Handle/Body
	- 适用性
		- 不希望在抽象和它的实现部分之间有一个固定的绑定关系。
		- 类的抽象已经它的实现都应该可以通过生成子类的方法加以扩充。
		- 对一个抽象的实现部分的修改应对客户不产生影响，即代码不必重新编译。
		- 想对客户完全隐藏实现的细节
		- 想在过个类中共享实现，但客户不知道这点。
	- 效果
		1. 分离接口及其实现部分
		2. 提高可扩充性
		3. 实现细节对客户透明
	- 实现
		1. 仅有一个Implementor
		2. 创建正确的Implementor对象
		3. 共享Implementor对象
	- 相关模式
		- AbsFactory可以用来创建和配置一个特定的Bridge模式
		- Adapter用来帮助无关类协同工作，它通常在系统设计完成后才会使用。Bridge则是一开始就会使用。

3. Composite
	- 意图
		将对象组合成树形结构以表示『部分-整体』的层次结构。使用户对单个对象和组合对象的使用具有一致性。
	- 适用性
		- 希望表示对象的部分-整体层次结构
		- 希望用户忽略组合对象与单个对象的不同。
	- 效果
		- 定义了包含基本对象和组合对象的类层次结构
		- 简化客户代码
		- 使得更容易Add新类型的组件
		- 使设计更一般化
	- 实现
		1. 显式的父组件引用
		2. 共享组件
		3. 最大化Component接口
		4. 声明管理子组件的操作
		5. Component是否应该实现一个Component列表
		6. 子部件排序
		7. 使用高速缓冲存储改善性能
		8. 应该由谁删除component
		9. 存储组件最好用什么数据结构
	- 相关模式
		- 通常组件-父组件连接用于Responsibility of Chain模式。
		- Decorator经常与Composite一起使用。
		- Flyweight让你共享组件，但不能能引用他们的副组件。
		- Iterator可以遍历Composite
		- Visitor将本来应该分布在Composite和Leaf类中的行为局部化。

4. Decorator
	- 意图
		动态地给一个对象添加一些额外的职责。
	- 别名
		Wrapper
	-  适用性
		- 不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
		- 处理那些可以撤销的职责
		- 不能采用生成子类的方法进行扩充时。
	- 效果
		- 优点：
			- 比静态继承更灵活
			- 避免在层次系统高层的类有太多的特征
		- 缺点：
			- Decorator和Component不一样
			- 有许多小对象
	- 实现
		- 接口一致性
		- 忽略抽象的Decorator类
		- 保持Component类的简单性
		- 改变对象与改变对象内核
	- 相关模式
		- Decorator与Adapter不同，因为Decorator仅改变对象的职责而不改变它的接口。
		- Decorator可以视为一个退化的、仅有一个组件的Composite。Decorator仅给对象添加一些额外的职责。
		- Decorator改变外表，Strategy改变内核。

5. Facade
	- 意图
		为子系统中的一组接口提供一个一致的界面，定义了一个高层接口。
	- 适用性
		- 为一个复杂的子系统提供一个简单的接口。
		- 客户程序和抽象类的实现部分之间存在着很大的依赖性。
		- 需要构建一个层次结构的子系统，Facade做每层接入点。
	- 优点：
		- 它对用户屏蔽了子系统组件。
		- 它实现了子系统与客户之间的松耦合关系。
		- 如果应用需要，它并不限制它们的子系统类。
	- 实现
		- 降低客户-子系统之间的耦合度
		- 公共子系统类与私有子系统类
	- 相关模式
		- Abstract Factory可以和Facade一起使用以提供一个接口。
		- Mediator和Facade相似之处是它抽象了已有的类的功能。然而，Mediator目的是对同事之间的任意通讯进行抽象，通常不是单一对象的功能。Mediator同事是知道中介者的。
		- 如仅需要一个Facade，则一般为Singleton。

6. Flyweight
	- 意图
		运用共享技术有效支持大量细腻度的对象。
	- 适用性
		- 一个应用程序使用了大量的抽象
		- 完全由于使用大量的对象，造成很大的开销
		- 对象的大多数状态都可变为外部状态
		- 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
	- 效果
		- 传输、查找和/或计算外部状态都会产生运行时开销。空间节省抵消了这些开销。
		- 节约因素：
			- 共享
			- 内部状态平均数
			- 外部状态存储还是节约
	- 实现
		- 删除外部状态
		- 管理共享对象
	- 相关模式
		- Flyweight通常和Composite结合使用。
		- 最好用Flyweight实现State和Strategy
7. Proxy
	- 意图 为其他对象提供一种代理以控制对象的访问。
	- 别名 Surrogate
	- 适用性
		- 远程代理
		- 虚代理
		- 保护代理
		- 智能指引
	- 效果
		1. Remote Proxy可以隐藏对象不在一个地址空间的事实。
		2. Virtual Proxy可以进行最优化。
		3. Protect Proxies和Smart Reference都允许在访问一个对象时添加内务管理。
	- 实现
		- Proxy被不总是知道实体类型
	- 相关模式
		- Adapter为它所适配的对象提供了一个不同的接口。
		- Decorator的目的不一样，是为了加一个或多个功能。
