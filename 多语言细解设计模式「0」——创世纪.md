title: 多语言细解设计模式「0」——创世纪
category: 编程
tag: [编程, 代码, 设计模式, 编程语言, C++, JS, Java, Python]
-------


# 为什么要有设计模式？

设计面向对象软件比较困难，而设计可复用的面向对象软件就更加困难。你希望避免重复设计或尽可能少做重复设计。一个设计在最终完成之前常要被复用好多次，而且每一次都有所修改。

有经验的面向对象设计者的确能做出良好的设计，而新手则面对众多选择无从下手，总是求助于以前使用的非面向对象技术。

内行的设计者知道：不是解决任何问题都要从头做起。他们更愿意复用之前使用过的解决方案。当找到一个好的解决方案，他们会一遍又一遍地使用。

《设计模式》这本书的目的就是将面向对象软件的设计经验作为设计模式记录下来。每一个软件模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。

设计模式使人们可以更加简单方便地复用成功的设计和设计结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。设计模式帮助你做出有利于系统复用的选择，避免设计损害了系统复用性。通过提供一个显示类和对象作用关系以及它们之间潜在联系的说明规范，设计模式甚至能够提高已有系统的文档管理和系统维护的有效性。In a word, 设计模式可以帮助设计者更好更快地完成系统设计。

# 什么设计模式

> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。

一个模式一般有四个基本要素：

1. 模式名称
2. 问题
3. 解决方案
4. 效果

出发点的不同会产生对什么事模式和什么不是模式的理解不同。一个人的模式对另一个人来说可能只是基本的Building blocks。

《设计模式》是*对被用来在特定场景下解决一个设计问题的类和相互通信的对象的描述*。

一个设计模式命名、抽象和确定了一个通用设计结构的主要方面，这些设计结构能被用来构造可复用的面向对象设计。设计模式确定了所包含的类和实例，它们的角色、协作方式以及职责分配。

# 设计模式的组织

## 按照目的分类

- 创建型
	
	- Factory Method
	- Abstract Factory
	- Builder
	- Prototype
	- Singleton
 
- 结构型

	- Adapter
	- Bridge
	- Composite
	- Decorator
	- Facade
	- Flyweight
	- Proxy

	
- 行为型

	- Interpreter
	- Template Method
	- Chain of Responsibility
	- Command
	- Iterator
	- Mediator
	- Memento
	- Observer
	- State
	- Strategy
	- Visitor

## 按照范围分类

除了Factory Method、Adapter、Interpreter、Template Method是主要用于类，其他都是用于对象。

## 通述

创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。

结构型类模式使用继承机制来组合类，而结构型类对象模式则描述了对象的组装方式。

行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎么协作完成单个对象所无法完成的任务。

还有其他组织模式的方式。有些模式经常会被绑在一起使用。有些模式则是可替代的。有些模式尽管使用意图不同，但产生的设计结果是很相似的。

# 设计模式怎样解决设计问题

## 寻找合适的对象

面向对象程序由对象组成，对象在接收到客户的请求后，执行操作。

客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。由于这些限制，对象的内部状态是被封装的。

面向对象设计最难的部分是将系统分解成对象集合。因为要考虑许多因素：封装、颗粒、依赖关系、灵活性、性能、演化、复用等等。它们都影响着系统的分解，并且这些因素通常还是互相冲突的。

设计模式帮你确定并不明显的抽象和描述这些抽象的对象。

## 决定对象的粒度

对象在大小和数目上变化极大。那么我们怎么决定一个对象应该是什么呢？

设计模式很好解决了这个问题。

## 指定对象接口

对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构（signature）。对象操作所定义的所有操作型构的集合被称作该对象的接口。类型是用来表示一个特定接口的名字。

接口可以包含其他接口作为子集。

在面向对象系统中，接口是基本的组成部分。

发送给对象的请求和它的对应操作在运行思科的连接就称之为动态绑定。

动态绑定是指发送的请求直到运行时刻才受你的具体的实现的约束。

动态绑定允许你在运行时刻彼此替换有相同接口的对象。

这种可替换性被称作多态。

设计模式通过确定接口的主要组成成分及经接口发送的数据类型，来帮助你定义接口。

设计模式也定义了接口之间的关系。

## 描述对象的实现


抽象类的主要目的是为它的子类定义公共接口。

子类能够改进和重新定义它们父类的操作。

混入类是给其他类可选择的接口或功能类。

对接口编程，而不是对实现编程。

## 运用复用机制

### 继承和组合的比较

类继承允许你根据其他类的实现来定义一个类的实现——白箱复用。

组合被视为黑箱复用。

组合和继承各有优缺点。类继承是在编译时期静态定义的。但是类继承也有不足：由于编译时期定义，所以无法在运行时改变父类的实现。继承破坏了「封装性」。

组合是通过获得对其他对象的引用在运行时刻动态定义的。并不破坏封装性。

优先使用对象组合，而不是类继承。

### 委托

委托是一种组合方法，它使得组合具有与继承同样的复用能力。

委托的优点: 运行时组合对象操作已经改变这些操作的组合方式。

委托的不足： 动态的高度参数化软件比静态软件更难以理解。

委托是对象组合的特例。

### 继承和参数化类型的比较

参数化类型也称作模板。

参数化类型允许你改变类所用到的类型。但是继承和参数化类型都不能在运行时改变。


## 关联运行时刻和编译时刻的结构

聚合意味着一个对象拥有另一个对象或者为另一个对象负责。

相识意味着一个对象仅仅知道另一个对象。有时也被称为关联或者引用。相识是一种比聚合要弱的关系。

从根本上讲，是聚合还是相识是由你的意图而不是显式的语言机制决定的。

聚合关系使用较少且比相识关系更持久；而相识关系出现频率较高。

程序的运行时刻结构和编译时刻结构存在这么大的差别，很明显代码不可能揭示一个关于系统如何工作的全部。

## 设计应支持变化

为了获得最大限度复用能力，这要求你的系统设计要能够适应这种可预见的变化。

设计模式可以确保系统能以特定方式运行，从而帮助你的避免重新设计系统。

1. 通过显式地指定一个类来创建对象
2. 对特殊操作的依赖
3. 对硬件和软件平台的依赖
4. 对设计表示或实现的依赖
5. 算法依赖
6. 紧耦合
7. 通过生成子类来扩充功能
8. 不能方便地对类进行修改


设计模式作用于：

应用程序：

增加内部复用性、可维护性、可扩充性。

工具库：

强调代码复用性。

框架：

框架是构成一类特定软件可复用设计的一组互相协作的类。

框架规定了你的应用的体系结构。

这个层次的复用导致了应用和它所基于的软件之间的IOC。

模式与框架的不同：

1. 设计模式比框架更抽象
2. 设计模式是比框架更小的体系结构元素
3. 框架比设计模式更加特例化

# 怎么选择设计模式

- 考虑设计模式是怎么解决设计问题的
- 浏览模式的意图部分
- 研究模式怎样相互关联
- 研究目的相似的模式
- 检查重新设计的原因
- 考虑你的设计中哪些是可变的

# 怎样使用设计模式

一个方法：

1. 大致浏览一遍模式
2. 回头研究结构部分、参与者部分和协作部分
3. 看代码示例部分
4. 选择模式参与者的名字，使它们在应用上下文中有意义
5. 定义类
6. 定义模式
7. 实现执行模式中责任和协作的操作

